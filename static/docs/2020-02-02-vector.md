---
title: Vector
published: true
description: An experiment about finding a simpler way to express vector math in Go.
created: 2020-02-02 10:09
tags:
cover: linear-gradient(339deg, rgba(34,193,195,1) 0%, rgba(253,187,45,1) 100%)
menu-color: white
---

<style>
svg#vector-field {
  max-width: 500px;
}

p:only-of-type svg#vector-field {
  baground: red;
}

svg #winds {
  fill: var(--grey);
}

.dark svg #winds {
  fill: var(--lighter-dark);
}

svg #avg-winds {
  fill: var(--darker-blue);
}

.table-of-contents ul {
  margin-top: 0px;
}

.table-of-contents li:before,
.dark .table-of-contents li:before  {
  color: var(--darker-blue);
}
</style>

In this post I will dive into vector math in Go and how I think we can improve
on existing solutions. The key areas i want to improve with this experiment is
regarding usability, readability and maintainability of vector math in Go.
The introduced changes maybe even improve on performance in some cases, see
provided [example](#example) in the end of this post.

This post is based on my own experience working with vector math in Go. Its based
on the usage of thirdparty packages as well as homebrewed implementations.

I will draw some comparisons to [Gonum](https://github.com/gonum/gonum), because it
seems like the most adopted and performant way of doing vector math in Go.
It is important to emphasis that this is not a rant on Gonum in any way.
It is about exploring a different approach for how vector math could be expressed
as Go syntax.

The code presented in this post is open source and licensed under the MIT license
and include internal code from Gonum that are licensed under the 3-Clause-BSD.
The code can be found at [`github.com/kvartborg/vector`](https://github.com/kvartborg/vector).

<div class='table-of-contents'>

##### Table of contents:
  * [**Why?**](#why)
  * [**How can we do better?**](#how-can-we-do-better)
  * [**Implementation**](#implementation)
    * [**Tackling verbosity**](#tackling-verbosity)
    * [**Immutability vs Mutability**](#immutability-vs-mutability)
  * [**Example**](#example)
    * [**Performance**](#performance)
  * [**Conclusion**](#conclusion)

</div>

### Why?
First of all why do we even need another solution when others already exist?
Let me try to explain with an example.

Through my experience working with different vector packages, one of
the major problems I have encountered, is related to instantiation of vectors.
It has a tendcy to get verbose which has an impact on usability, readability and
maintainability of vector math packages.

To prove my point i have written a simple example to demonstrate the problem in
practise. Lets start by defining the problem I want to solve.

Lets say I have two vectors $$ a $$ and $$ b $$.
<center>
  $$ a = (1, 2) $$
  <span style="width:var(--spacing); display:inline-block"></span>  
  $$ b = (2, 4) $$
</center>

And I want to add them together to get the resulting vector $$ c $$.

$$ c = a + b $$

This is very basic problem, and is easily expressed and solved in code with Gonum.
But because it is simple, it really highlight the problem vector instantiation
and how it adds a lot of unnecessary noise to the code.

```go
c := mat.NewVecDense(2, nil)
a := mat.NewVecDense(2, []float64{1, 2})
b := mat.NewVecDense(2, []float64{2, 4})
c.AddVec(a, b)
```
As it can be seen in the example above, it is mostly vector instantiation
compared to the last line were the addition of the vectors actually is done.

Another problem is that the vector dimension has to be specified as the
first argument in the `NewVecDense` constructor, which is reduntant
when the list given as the second argument implicitly contains the value as
its length. But it is necessary because of the first line where the receiving vector $$ c $$ is created.
A receiving vector is zero vector that receives the result of the operation `AddVec`.

The concept of a receiving vector also adds a mental overhead when the code is
read. This can make the implementation harder to reason about, which in turn
makes it harder to maintain and evolve.
There is a good reason behind the concept of the receiving vector and in some
cases it is a good approach, but in many cases it can be omitted.

The example given here is written with Gonum, but it is a general problem
for most of the vector packages i have used.


### How can we do better?

Lets draft the ideal solution as valid Go syntax. I have tried to
come up with what i think is the best way to express the solution to the problem
from before.

```go
a, b := vec{1, 2}, vec{2, 4}
c := a.Add(b)
```

As it can be seen in the draft, vectors are easily instantiated without the need
for any constructor function and without any reduntant parameters. The
receiving vector is also omitted and instead $$ c $$ is allocated as the
result of adding $$ a $$ and $$ b $$ together.

This drafted solution will even allow the problem to be specifed as a single line
that somewhat resembles the mathematical expression of the problem.

$$ c = (1, 2) + (2, 4) $$

<center>
<pre><code class='language-go' style='background:transparent;font-size:.96em;padding:0px;display:inline;'>c := vec{1, 2}.Add(vec{2, 4})</code></pre>
</center>

It is a subtle change from the Gonum approach. But in my opion it is huge
improvement in terms of usability, readability and maintainability of vector math.

Now that we have drafted how the solution could be expressed as Go syntax,
we can dive into how to implement a package that enable developers to write
vector math as shown in the drafted example. If you just want to see it
work in practise you can skip the implementation section and jump to
the [example](#example).

### Implementation

Lets explore how a package named `vector` can be implemented based on the drafted
solution from previous section.
The first step is to find the ideal way to represent a vector
as code. To do this lets take a look at the definition of a vector.

> A vector is given by $$ n $$ coordinates and can be specified as $$ (A_1, A_2, ..., A_n) $$
  Vectors are sometimes referred to by the number of coordinates they have,
  so a 2-dimensional vector $$ (x_1,x_2) $$ is often called a two-vector,
  an $$ n $$-dimensional vector is often called an $$ n $$-vector. <br>
  \- [Wolfram](http://mathworld.wolfram.com/Vector.html)

As the difinition states, a vector is basically a list of $$ n $$ numbers, which
can easily be represented in Go as a type `Vector` that is a list of
`float64` values.

```go
// A Vector is simply a list of float64 values
type Vector []float64
```

By representing a `Vector` as a list of `float64` values we gain a lot of
benefits for free, first of all it is simple, resembles the difinition well and
it has a lot of benefits in regard to Vector instantiation which i will dive into
in the next couple of examples.

As i see it we need three ways to create a `Vector`, the first is just a normal
instantiation from a set of `float64` values, the second is turning a existing
`[]float64` value into a `Vector` and the last is creating a zero vector of some
specific dimensional size. Let see how we can achieve those three cases without
the need for any constructor functions.
```go
// Instantiate a new Vector from the concrete type
a := Vector{1, 2}

// Cast an existing list of float64 values to a Vector
b := Vector([]float64{2, 4})

// Create a 100-dimensional zero Vector
z := make(Vector, 100)
```
As it can be seen in the example above, we can leverage the Go way of working
with types and eliminate the need for any constructor functions for the
`Vector` type.

Another benifit of this represention of a `Vector` is that values of type `[]float64`
actually are valid vectors without explicitly stating it. This allows `[]float64` values to be passed directly to any
function that accepts a `Vector` as an argument without any manual casting.
This is powerful and it enables developers to keep vectors as `[]float64` values
when passed around to different functions, over the network or when encoding/decoding a `Vector` to another data format. It makes
the vector type, package agnostic because the internal `[]float64` is equally representing
a vector, just without any of the operations provided by the vector package.

```go
// You can pass []float64 values directly to functions that
// accepts a Vector as an argument, Go will automatically
// ensure to cast the type to a Vector.
c := Vector{1, 2}.Add([]float64{2, 4})
```

This also goes the other way around, and enables a value of type `Vector` to be
passed to any function that takes a an argument of type `[]float64`. An example
could be that you have a `Vector` and want to convert it into a `*VecDense` from
Gonum.
```go
v := mat.NewVecDense(2, Vector{1, 2})
```

Everything you can do with list in Go, you can do with a `Vector` as well.
So lookups, slicing and assignment of a value on a specific index just works
the same as any other list would.
```go
// Common list operations works with vectors as well
v := Vector{1, 2, 3}
v[1]     // returns 2
v[1:]    // returns Vector{2, 3}
v[1] = 4 // changes value at index 1
```


##### Tackling verbosity
By represeting a Vector as a list of `float64` values we can get close to the
drafted example, but there is still a problem with verbosity when instantiating
new vectors. As it can be seen in the example below the `vector.Vector` is
redundant, and hurts the usability and readability of the package.
```go
// Drafted example based on the Vector type
a, b := vector.Vector{1, 2}, vector.Vector{2, 4}
c := a.Add(b)
```
The best way i have found to tackle this problem is by utilizing Go type aliasing.
```go
// Minimize the verbosity by using type aliasing
type vec = vector.Vector
```
In this way you can omit the package identifier and give the `Vector`
a shorter name like `vec` or something else, it is up to you.

By using type aliasing we can achieve working code as in the drafted
example.

##### Immutability vs Mutability
Most of the arithmetic operations provided by this package has a mutable and
immutable implementation.
The way this is separated is that all package level functions are immutable and
methods called on the vector it self are mutable on the calling vector.

```go
// Create vectors
a, b := vec{1, 2}, vec{2, 4}

// Immutable addition, returns a new vector
c := vector.Add(a, b)

// Mutable addition, will do the calculation in place in the a vector
c := a.Add(b)
```

The mutable implementation is a lot faster and uses less memory compared to the
immutable, this is because the calculation is done in place.
Mutable operations shall be used with care, because it can lead to bugs that
can be hard to spot. A use case i find useful is to use mutable operations when
you are inlining instantiation of the vectors.

```go
// example of safe usage of mutable operations when inlining
// vector instantiation.
c := vec{1, 2}.Add(vec{2, 4})
```

Or if you are creating a receiving vector where the calculation can be done
in place.

```go
// Create receiving vector where the calculation can be done in place.
c := make(vec, 2)

// Create vectors
a, b := vec{1, 2}, vec{2, 4}

// safe usage of mutable operation when called on a result vector
c.Add(a, b)
```

This is a very basic description of how the [`github.com/kvartborg/vector`](https://github.com/kvartborg/vector)
package is implemented and the usage of the API. It only touches on some of the
arithmetic operations it supports.
See the full documentation and examples at [Godoc](https://pkg.go.dev/github.com/kvartborg/vector?tab=doc)
for more information about the usage of this package.

### Example

Until now I have only presented very simple examples, which showcase the main
pain points I'm trying to address with this package. To further verify the
improvements i will in this section showcase a real world problem solved with  
Gonum and the vector package presented in this post. I will compare the implementations
based on number of characters and performance.

<center>

  ![vector field](/static/imgs/vector-field.svg)

</center>

The problem that are going to be solve in this example is as follows. As it can be seen
in the illustration above we are given a vector field of winds. All the grey arrows
are the winds that has been observed and the blue one is the average wind that can
be computed based on the observed winds.

Before we look at the code, lets first outline the steps involved to get to the
correct answer:
  * Find the avarage direction of the observed winds
  * Find the avarage speed of the observed winds
  * Compute the avarege wind from the avarage direction and speed.

```go
// Gonum
func AverageWind(winds []*mat.VecDense) *mat.VecDense {
    // Find average direction of winds
    r := mat.NewVecDense(2, nil)
    for i := range winds {
        r.AddVec(r, winds[i])
    }
    direction := math.Atan2(r.AtVec(1), r.AtVec(0))

    // Find average speed of winds
    var speed float64
    for i := range winds {
        speed += mat.Norm(winds[i], 2)
    }
    speed /= len(winds)

    // Create vector with magnitude of average speed and rotate it in
    // the average direction
    return mat.NewVecDense(2, []float64{
        math.Cos(direction)*speed,
        math.Sin(direction)*speed,
    })
}
```

```go
// github.com/kvartborg/vector
func AverageWind(winds []vec) vec {
    // Find average direction of winds
    r := make(vec, 2).Add(winds...)
    direction := math.Atan2(r[1], r[0])

    // Find average speed of winds
    var speed float64
    for i := range winds {
        speed += winds[i].Magnitude()
    }
    speed /= len(winds)

    // Create vector with magnitude of average speed and rotate it in
    // the average direction
    return vec{speed}.Rotate(direction)
}
```

If we compare the character count of the two implementation, we will see that
`vector` contains `27.8%` less characters compared to the `gonum` implementation.

<!-- And in my opinion it does not have any negative impact of the expressiveness of
the code. I really like how the implementation with `vector` reads and how it
was to write when i solved this problem. -->

##### Performance

![Average Wind](/static/imgs/average-wind.svg)

### Conclusion


### Contribution
It is based on my own experience working with vector math in Go projects at DanaDynamics, and therefore the focus has been on operations that we use. Contributions with common operations that aren't included in this package yet are very welcome. So is comments/suggestions in the form of issues on [GitHub](https://github.com/kvartborg/vector).

### Credits
Thanks to [`gonum`](https://github.com/gonum/gonum) for inspiration and the following functions [`axpyUnitaryTo`](https://github.com/gonum/gonum/blob/master/internal/asm/f64/axpyunitaryto_amd64.s), [`scalUnitaryTo`](https://github.com/gonum/gonum/blob/c3867503e73e5c3fee7ab93e3c2c562eb2be8178/internal/asm/f64/scalunitaryto_amd64.s) that enhances the performance of arithmetic operations in this package.
